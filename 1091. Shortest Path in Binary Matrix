class Solution {
    public class tuple{
        int first;
        int second;
        int  third;
        public tuple(int first, int second, int third){
            this.first = first;
            this.second = second;
            this.third = third;
        }
    }
    public int shortestPathBinaryMatrix(int[][] grid) {
        int n = grid.length; 
        if(grid[0][0] == 1 || grid[n-1][n-1] == 1){
            return -1;
        }
        if(n == 1){
            return 1;
        }
        int[][] vis = new int[n][n];
        PriorityQueue<tuple> pq = new PriorityQueue<>(new Comparator<tuple>(){
            @Override
            public int compare(tuple o1, tuple o2){
                return o1.first - o2.first;
            }
        });

        for(int[] a : vis){
            Arrays.fill(a,(int)(1e9));
        }
        vis[0][0] = 0;
        pq.add(new tuple(1,0,0));
        while(!pq.isEmpty()){
            tuple rv = pq.poll();
            int des = rv.first;
            int r = rv.second;
            int c = rv.third;
            for(int i = -1; i<=1; i++){
                for(int j = -1; j<=1; j++){
                    int cr = r+i;
                    int cc = c+j;
                    if(cr >= 0 && cc >= 0 && cr < n && cc < n && grid[cr][cc] == 0 && des+1 < vis[cr][cc]){
                        if(cr == n-1 && cc == n-1){
                            return des+1;
                        }
                        pq.add(new tuple(des+1,cr,cc));
                        vis[cr][cc] = des+1;
                    }
                }
            }
        }
        return -1;
    }
}
